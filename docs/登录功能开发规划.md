# 登录功能开发规划

## 概述
本规划详细描述了学校综合管理系统的登录功能开发方案，涵盖数据库设计、后端认证、前端界面、权限控制等完整实现路径。系统将基于现有架构进行扩展，实现用户登录、权限识别、动态菜单等功能。

## 一、数据库设计

### 1.1 现有表结构分析
当前系统已存在 `persons` 表作为人员基础信息表，包含以下字段：
- `id` (UUID, 主键)
- `name` (姓名)
- `gender` (性别)
- `birthday` (生日)
- `phone` (电话)
- `email` (邮箱)
- `type` (类型: student/teacher/parent)
- `created_at` / `updated_at` (时间戳)

### 1.2 登录功能字段扩展
为实现登录功能，需要在 `persons` 表中添加以下字段：

```sql
-- 添加登录相关字段到 persons 表
ALTER TABLE persons 
ADD COLUMN username VARCHAR(50) UNIQUE,
ADD COLUMN password_hash VARCHAR(255),
ADD COLUMN role VARCHAR(20) DEFAULT 'user',
ADD COLUMN is_active BOOLEAN DEFAULT true,
ADD COLUMN last_login_at TIMESTAMP WITH TIME ZONE;
```

**字段说明：**
- `username`: 用户名，唯一标识，用于登录
- `password_hash`: 密码哈希值（使用 bcrypt 算法）
- `role`: 用户角色（admin/teacher/student/parent）
- `is_active`: 账户是否激活
- `last_login_at`: 最后登录时间

### 1.3 默认用户与密码策略
1. **预留管理员账户**：
   ```sql
   INSERT INTO persons (id, name, username, password_hash, role, type, is_active) 
   VALUES (
       '00000000-0000-0000-0000-000000000000',
       '系统管理员',
       'admin',
       -- bcrypt hash of 'admin' (cost 12)
       '$2b$12$LQv3c1yqBWVHxpd5g6TAkO6l4dQjHZjXlWfLp.aC.9r7t4bJF1WKK',
       'admin',
       'teacher',
       true
   );
   ```

2. **默认密码策略**：
   - 新建用户未设置密码时，默认密码为 `123456`
   - 密码存储使用 bcrypt 哈希算法（cost=12）
   - 首次登录后强制修改密码（未来扩展）

### 1.4 索引优化
```sql
-- 用户名索引（登录时快速查找）
CREATE INDEX idx_persons_username ON persons(username);

-- 角色索引（权限查询优化）
CREATE INDEX idx_persons_role ON persons(role);
```

### 1.5 数据库迁移文件
创建新的迁移文件：`backend/migrations/002_add_login_fields_to_persons.sql`

## 二、后端认证系统设计

### 2.1 技术栈与依赖
- **Web框架**: Axum 0.7
- **JWT**: jsonwebtoken 9.2
- **密码哈希**: bcrypt 0.15 (新增依赖)
- **数据库**: SQLx + PostgreSQL

### 2.2 核心模块结构
```
backend/src/
├── core/
│   ├── auth.rs          # JWT令牌生成/验证
│   ├── password.rs      # 密码哈希验证
│   └── middleware/      # 认证中间件
│       └── auth_middleware.rs
├── api/
│   ├── auth.rs          # 登录/登出API
│   └── user.rs          # 用户管理API
├── models/
│   ├── user.rs          # 用户模型（扩展Person）
│   └── person.rs        # 现有模型更新
└── services/
    └── auth_service.rs  # 认证业务逻辑
```

### 2.3 密码哈希模块 (`core/password.rs`)
```rust
use bcrypt::{hash, verify, DEFAULT_COST};

pub fn hash_password(password: &str) -> Result<String, anyhow::Error> {
    hash(password, DEFAULT_COST).map_err(|e| anyhow::anyhow!(e))
}

pub fn verify_password(password: &str, hash: &str) -> Result<bool, anyhow::Error> {
    verify(password, hash).map_err(|e| anyhow::anyhow!(e))
}
```

### 2.4 JWT认证增强 (`core/auth.rs`)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,      // 用户ID
    pub username: String, // 用户名
    pub role: String,     // 用户角色
    pub exp: u64,         // 过期时间
}

// 令牌生成函数（支持自定义过期时间）
pub fn generate_token(user_id: &str, username: &str, role: &str, secret: &str, expires_in_hours: u64) -> Result<String, anyhow::Error> {
    let expiration = SystemTime::now() + Duration::from_secs(expires_in_hours * 3600);
    let exp = expiration.duration_since(UNIX_EPOCH)?.as_secs();
    
    let claims = Claims {
        sub: user_id.to_string(),
        username: username.to_string(),
        role: role.to_string(),
        exp,
    };
    
    let secret = EncodingKey::from_secret(secret.as_ref());
    let token = encode(&Header::default(), &claims, &secret)?;
    
    Ok(token)
}

// 令牌验证函数
pub fn verify_token(token: &str, secret: &str) -> Result<Claims, anyhow::Error> {
    let secret = DecodingKey::from_secret(secret.as_ref());
    let validation = Validation::default();
    
    let token_data = decode::<Claims>(token, &secret, &validation)?;
    Ok(token_data.claims)
}
```

### 2.5 认证中间件 (`core/middleware/auth_middleware.rs`)
```rust
use axum::{extract::Request, middleware::Next, response::Response};
use axum_extra::headers::{authorization::Bearer, Authorization};
use axum_extra::TypedHeader;

pub async fn auth_middleware(
    TypedHeader(auth): TypedHeader<Authorization<Bearer>>,
    request: Request,
    next: Next,
) -> Result<Response, (StatusCode, String)> {
    let token = auth.token();
    
    // 验证令牌
    let config = load_config().map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    let claims = verify_token(token, &config.jwt_secret)
        .map_err(|_| (StatusCode::UNAUTHORIZED, "Invalid token".to_string()))?;
    
    // 将用户信息添加到请求扩展中
    let mut request = request;
    request.extensions_mut().insert(claims);
    
    Ok(next.run(request).await)
}
```

### 2.6 登录API增强 (`api/auth.rs`)
```rust
#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
    #[serde(default)]
    pub remember_me: bool, // 记住我功能
}

#[derive(Debug, Serialize)]
pub struct LoginResponse {
    pub token: String,
    pub user: UserInfo,
    pub permissions: Vec<String>, // 用户权限列表
    pub expires_in: u64,          // 令牌过期时间（秒）
}

pub async fn login(
    State(state): State<AppState>,
    Json(login_req): Json<LoginRequest>,
) -> Result<Json<LoginResponse>, (StatusCode, String)> {
    // 1. 查询用户
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM persons WHERE username = $1 AND is_active = true",
        login_req.username
    )
    .fetch_optional(&state.pool)
    .await
    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    // 2. 验证用户存在
    let user = user.ok_or((StatusCode::UNAUTHORIZED, "用户名或密码错误".to_string()))?;
    
    // 3. 验证密码
    let password_valid = verify_password(&login_req.password, &user.password_hash)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    if !password_valid {
        return Err((StatusCode::UNAUTHORIZED, "用户名或密码错误".to_string()));
    }
    
    // 4. 加载配置
    let config = load_config().map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    // 5. 生成令牌（根据remember_me设置不同过期时间）
    let expires_in_hours = if login_req.remember_me { 24 * 7 } else { 24 }; // 7天或1天
    let token = generate_token(&user.id.to_string(), &user.username, &user.role, &config.jwt_secret, expires_in_hours)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    // 6. 更新最后登录时间
    sqlx::query!("UPDATE persons SET last_login_at = NOW() WHERE id = $1", user.id)
        .execute(&state.pool)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    
    // 7. 构建响应
    let response = LoginResponse {
        token,
        user: UserInfo {
            id: user.id.to_string(),
            username: user.username,
            role: user.role,
            name: user.name,
            email: user.email,
        },
        permissions: get_user_permissions(&user.role),
        expires_in: expires_in_hours * 3600,
    };
    
    Ok(Json(response))
}

// 获取用户权限函数
fn get_user_permissions(role: &str) -> Vec<String> {
    match role {
        "admin" => vec![
            "dashboard.view",
            "person.manage",
            "class.manage", 
            "department.manage",
            "attendance.manage",
            "score.manage",
            "notice.manage",
            "system.settings",
        ],
        "teacher" => vec![
            "dashboard.view",
            "person.view",
            "class.view",
            "attendance.manage",
            "score.manage",
            "notice.view",
        ],
        "student" => vec![
            "dashboard.view",
            "person.view",
            "attendance.view",
            "score.view",
            "notice.view",
        ],
        "parent" => vec![
            "dashboard.view",
            "person.view",
            "attendance.view",
            "score.view",
            "notice.view",
        ],
        _ => vec!["dashboard.view"],
    }
}
```

### 2.7 用户信息API (`api/user.rs`)
```rust
// 获取当前用户信息
pub async fn get_current_user(
    State(state): State<AppState>,
    Extension(claims): Extension<Claims>,
) -> Result<Json<UserInfo>, (StatusCode, String)> {
    // 从令牌中提取用户信息
    Ok(Json(UserInfo {
        id: claims.sub,
        username: claims.username,
        role: claims.role,
        // 可以根据需要从数据库查询更多信息
        name: "".to_string(),
        email: "".to_string(),
    }))
}
```

### 2.8 路由配置更新 (`api/routes.rs`)
```rust
// 认证路由组（无需认证）
let auth_routes = Router::new()
    .route("/login", post(auth::login))
    .route("/logout", post(auth::logout));

// 需要认证的路由组
let protected_routes = Router::new()
    .route("/user/me", get(user::get_current_user))
    .route("/user/profile", put(user::update_profile))
    .layer(middleware::from_fn(auth_middleware));

// 主路由
Router::new()
    .nest("/api/auth", auth_routes)
    .nest("/api", protected_routes)
    // 其他现有路由...
```

## 三、前端登录页面设计

### 3.1 现有登录页面分析
当前 `LoginView.vue` 已实现基本登录表单，但使用模拟数据。需要改造为真实API调用。

### 3.2 样式规范（参考ArkUI设计）
**设计原则：**
- 简洁现代，符合教育管理系统定位
- 使用ArkUI的色彩体系和阴影参数
- 响应式设计，支持移动端

**颜色规范：**
- 主色调：`#409EFF`（Element Plus 蓝色）
- 背景色：`#F0F2F5`（浅灰背景）
- 卡片背景：`#FFFFFF`（纯白）
- 文字颜色：`#303133`（主要文字）
- 辅助文字：`#909399`
- 边框颜色：`#DCDFE6`

**阴影规范：**
```css
box-shadow: 0 2px 12px 0 rgba(78, 89, 105, 0.06); /* ArkUI阴影参数 */
```

**字体规范：**
```css
font-family: 'Noto Sans SC', 'Microsoft YaHei', sans-serif;
```

### 3.3 登录页面改造 (`LoginView.vue`)
```vue
<template>
  <div class="login-container">
    <div class="login-card">
      <!-- Logo区域 -->
      <div class="login-header">
        <h1 class="login-title">学校综合管理系统</h1>
        <p class="login-subtitle">School Management System</p>
      </div>
      
      <!-- 登录表单 -->
      <el-form 
        :model="loginForm" 
        :rules="rules" 
        ref="loginFormRef" 
        class="login-form"
        label-position="top"
      >
        <el-form-item label="用户名" prop="username">
          <el-input 
            v-model="loginForm.username" 
            placeholder="请输入用户名"
            prefix-icon="User"
            size="large"
          />
        </el-form-item>
        
        <el-form-item label="密码" prop="password">
          <el-input 
            v-model="loginForm.password" 
            type="password" 
            placeholder="请输入密码"
            prefix-icon="Lock"
            size="large"
            show-password
          />
        </el-form-item>
        
        <el-form-item>
          <el-checkbox v-model="loginForm.rememberMe">记住我</el-checkbox>
        </el-form-item>
        
        <el-form-item>
          <el-button 
            type="primary" 
            @click="handleLogin" 
            :loading="loading"
            size="large"
            class="login-button"
          >
            登录
          </el-button>
        </el-form-item>
      </el-form>
      
      <!-- 底部信息 -->
      <div class="login-footer">
        <p class="version-info">版本：v1.0.0</p>
        <p class="support-info">技术支持：xxx学校信息中心</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue'
import { useRouter } from 'vue-router'
import { ElMessage } from 'element-plus'
import type { FormInstance, FormRules } from 'element-plus'
import { authApi } from '@/api/auth'

const router = useRouter()
const loginFormRef = ref<FormInstance>()
const loading = ref(false)

const loginForm = reactive({
  username: '',
  password: '',
  rememberMe: false
})

const rules: FormRules = {
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, max: 20, message: '用户名长度 3-20 个字符', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 30, message: '密码长度 6-30 个字符', trigger: 'blur' }
  ]
}

const handleLogin = async () => {
  if (!loginFormRef.value) return
  
  try {
    await loginFormRef.value.validate()
    loading.value = true
    
    // 调用真实登录API
    const response = await authApi.login({
      username: loginForm.username,
      password: loginForm.password,
      remember_me: loginForm.rememberMe
    })
    
    // 存储令牌和用户信息
    localStorage.setItem('token', response.data.token)
    localStorage.setItem('user', JSON.stringify(response.data.user))
    localStorage.setItem('permissions', JSON.stringify(response.data.permissions))
    
    // 设置令牌过期时间（用于自动刷新）
    const expiresAt = new Date().getTime() + response.data.expires_in * 1000
    localStorage.setItem('token_expires_at', expiresAt.toString())
    
    ElMessage.success('登录成功')
    router.push('/dashboard')
  } catch (error: any) {
    const message = error.response?.data?.message || '登录失败，请检查用户名和密码'
    ElMessage.error(message)
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.login-card {
  width: 100%;
  max-width: 420px;
  padding: 40px;
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.12);
}

.login-header {
  text-align: center;
  margin-bottom: 40px;
}

.login-title {
  font-size: 24px;
  font-weight: 600;
  color: #303133;
  margin-bottom: 8px;
  font-family: 'Noto Sans SC', 'Microsoft YaHei', sans-serif;
}

.login-subtitle {
  font-size: 14px;
  color: #909399;
  margin: 0;
}

.login-form {
  margin-bottom: 30px;
}

.login-button {
  width: 100%;
  height: 48px;
  font-size: 16px;
  font-weight: 500;
  border-radius: 8px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
  transition: all 0.3s ease;
}

.login-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

.login-footer {
  text-align: center;
  border-top: 1px solid #f0f0f0;
  padding-top: 20px;
}

.version-info,
.support-info {
  font-size: 12px;
  color: #909399;
  margin: 4px 0;
}
</style>
```

### 3.4 认证API封装 (`api/auth.ts`)
```typescript
import api from './index'

export interface LoginRequest {
  username: string
  password: string
  remember_me?: boolean
}

export interface LoginResponse {
  token: string
  user: UserInfo
  permissions: string[]
  expires_in: number
}

export interface UserInfo {
  id: string
  username: string
  role: string
  name: string
  email: string
}

export const authApi = {
  login: (data: LoginRequest) => {
    return api.post<LoginResponse>('/auth/login', data)
  },
  
  logout: () => {
    return api.post('/auth/logout')
  },
  
  getCurrentUser: () => {
    return api.get<UserInfo>('/user/me')
  },
  
  refreshToken: () => {
    return api.post('/auth/refresh')
  }
}
```

### 3.5 Axios请求拦截器 (`api/index.ts`)
```typescript
import axios from 'axios'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api',
  timeout: 10000,
})

// 请求拦截器：添加JWT令牌
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器：处理401错误
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config
    
    // 401错误且不是登录请求
    if (error.response?.status === 401 && !originalRequest._retry && originalRequest.url !== '/auth/login') {
      originalRequest._retry = true
      
      try {
        // 尝试刷新令牌
        const refreshToken = localStorage.getItem('refresh_token')
        if (refreshToken) {
          const response = await api.post('/auth/refresh', { refresh_token: refreshToken })
          const newToken = response.data.token
          localStorage.setItem('token', newToken)
          
          // 重试原始请求
          originalRequest.headers.Authorization = `Bearer ${newToken}`
          return api(originalRequest)
        }
      } catch (refreshError) {
        // 刷新失败，跳转到登录页
        localStorage.clear()
        window.location.href = '/login'
        return Promise.reject(refreshError)
      }
    }
    
    return Promise.reject(error)
  }
)

export default api
```

## 四、权限管理与动态菜单

### 4.1 权限模型设计
基于角色的访问控制（RBAC）：
- **角色**：admin、teacher、student、parent
- **权限**：细粒度操作权限（如 person.view、person.manage）
- **菜单权限**：根据角色动态显示侧边栏菜单

### 4.2 权限映射配置
```typescript
// src/config/permissions.ts
export const rolePermissions = {
  admin: [
    'dashboard.view',
    'person.manage',
    'class.manage',
    'department.manage',
    'attendance.manage',
    'score.manage',
    'notice.manage',
    'system.settings',
  ],
  teacher: [
    'dashboard.view',
    'person.view',
    'class.view',
    'attendance.manage',
    'score.manage',
    'notice.view',
  ],
  student: [
    'dashboard.view',
    'person.view',
    'attendance.view',
    'score.view',
    'notice.view',
  ],
  parent: [
    'dashboard.view',
    'person.view',
    'attendance.view',
    'score.view',
    'notice.view',
  ]
}

export const menuPermissions = {
  dashboard: ['dashboard.view'],
  person: ['person.view', 'person.manage'],
  class: ['class.view', 'class.manage'],
  department: ['department.view', 'department.manage'],
  attendance: ['attendance.view', 'attendance.manage'],
  score: ['score.view', 'score.manage'],
  notice: ['notice.view', 'notice.manage'],
  system: ['system.settings']
}
```

### 4.3 动态菜单组件
```vue
<!-- src/components/layout/SidebarMenu.vue -->
<template>
  <el-menu
    :default-active="activeMenu"
    :unique-opened="true"
    router
    class="sidebar-menu"
  >
    <template v-for="item in filteredMenus" :key="item.path">
      <el-sub-menu v-if="item.children" :index="item.path">
        <template #title>
          <el-icon><component :is="item.icon" /></el-icon>
          <span>{{ item.title }}</span>
        </template>
        <el-menu-item
          v-for="child in item.children"
          :key="child.path"
          :index="child.path"
        >
          {{ child.title }}
        </el-menu-item>
      </el-sub-menu>
      <el-menu-item v-else :index="item.path">
        <el-icon><component :is="item.icon" /></el-icon>
        <span>{{ item.title }}</span>
      </el-menu-item>
    </template>
  </el-menu>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { useUserStore } from '@/stores/user'
import { menuItems } from '@/config/menu'

const route = useRoute()
const userStore = useUserStore()

const activeMenu = computed(() => route.path)

// 根据权限过滤菜单
const filteredMenus = computed(() => {
  return menuItems.filter(item => {
    // 检查菜单权限
    if (item.permission) {
      return userStore.hasPermission(item.permission)
    }
    // 检查子菜单权限
    if (item.children) {
      item.children = item.children.filter(child => 
        !child.permission || userStore.hasPermission(child.permission)
      )
      return item.children.length > 0
    }
    return true
  })
})
</script>
```

### 4.4 权限检查工具
```typescript
// src/utils/permission.ts
import { useUserStore } from '@/stores/user'

export function checkPermission(permission: string): boolean {
  const userStore = useUserStore()
  return userStore.hasPermission(permission)
}

export function checkRole(role: string): boolean {
  const userStore = useUserStore()
  return userStore.role === role
}
```

### 4.5 Pinia状态管理 (`stores/user.ts`)
```typescript
import { defineStore } from 'pinia'
import { UserInfo } from '@/api/auth'

interface UserState {
  user: UserInfo | null
  token: string | null
  permissions: string[]
  role: string | null
}

export const useUserStore = defineStore('user', {
  state: (): UserState => ({
    user: null,
    token: localStorage.getItem('token'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]'),
    role: localStorage.getItem('role')
  }),
  
  actions: {
    setUser(user: UserInfo) {
      this.user = user
      this.role = user.role
      localStorage.setItem('user', JSON.stringify(user))
      localStorage.setItem('role', user.role)
    },
    
    setToken(token: string) {
      this.token = token
      localStorage.setItem('token', token)
    },
    
    setPermissions(permissions: string[]) {
      this.permissions = permissions
      localStorage.setItem('permissions', JSON.stringify(permissions))
    },
    
    logout() {
      this.user = null
      this.token = null
      this.permissions = []
      this.role = null
      localStorage.clear()
    },
    
    hasPermission(permission: string): boolean {
      if (this.role === 'admin') return true
      return this.permissions.includes(permission)
    }
  }
})
```

## 五、路由守卫与认证检查

### 5.1 路由守卫配置 (`router/index.ts`)
```typescript
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/stores/user'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    // ... 现有路由配置
  ]
})

// 全局前置守卫
router.beforeEach((to, from, next) => {
  const userStore = useUserStore()
  const isAuthenticated = !!userStore.token
  
  // 不需要认证的路由
  const publicRoutes = ['/login', '/register']
  const isPublicRoute = publicRoutes.includes(to.path)
  
  // 如果未认证且访问非公开路由，重定向到登录页
  if (!isAuthenticated && !isPublicRoute) {
    next('/login')
    return
  }
  
  // 如果已认证且访问登录页，重定向到首页
  if (isAuthenticated && to.path === '/login') {
    next('/dashboard')
    return
  }
  
  // 检查路由权限
  if (to.meta?.permission) {
    if (userStore.hasPermission(to.meta.permission as string)) {
      next()
    } else {
      next('/403') // 无权限页面
    }
    return
  }
  
  next()
})

export default router
```

### 5.2 路由权限配置
```typescript
// 路由配置示例
const routes = [
  {
    path: '/dashboard',
    name: 'dashboard',
    component: DashboardView,
    meta: { 
      title: '仪表盘',
      permission: 'dashboard.view'
    }
  },
  {
    path: '/person',
    name: 'person',
    component: PersonView,
    meta: { 
      title: '人员管理',
      permission: 'person.view'
    }
  },
  // ... 其他路由
]
```

## 六、开发实施步骤

### 6.1 第一阶段：数据库迁移（1天）
1. 创建数据库迁移文件 `002_add_login_fields_to_persons.sql`
2. 执行迁移，添加登录字段到persons表
3. 插入默认管理员账户
4. 创建必要索引

### 6.2 第二阶段：后端功能开发（2天）
1. 添加bcrypt依赖，实现密码哈希模块
2. 增强JWT认证模块，支持自定义过期时间
3. 实现认证中间件
4. 改造登录API，支持真实数据库验证
5. 实现用户信息API
6. 更新路由配置

### 6.3 第三阶段：前端功能开发（2天）
1. 改造LoginView.vue，连接真实API
2. 实现认证API封装和Axios拦截器
3. 创建Pinia用户状态管理
4. 实现权限检查工具
5. 开发动态菜单组件
6. 配置路由守卫

### 6.4 第四阶段：测试与部署（1天）
1. 单元测试：认证相关功能
2. 集成测试：完整登录流程
3. 安全测试：SQL注入、XSS防护
4. 性能测试：登录响应时间
5. 部署上线

## 七、安全注意事项

### 7.1 密码安全
- 使用bcrypt哈希算法（cost=12）
- 禁止弱密码（123456、admin等）
- 密码长度最小6位
- 未来实现密码复杂度检查

### 7.2 令牌安全
- JWT令牌存储在HttpOnly Cookie中（未来改进）
- 设置合理的令牌过期时间
- 实现令牌刷新机制
- 令牌黑名单（未来扩展）

### 7.3 输入验证
- 后端对所有输入进行验证
- 防止SQL注入（使用SQLx参数化查询）
- 防止XSS攻击（输出编码）
- 请求频率限制（未来扩展）

### 7.4 日志记录
- 记录所有登录尝试（成功/失败）
- 记录敏感操作（密码修改、权限变更）
- 日志脱敏处理（不记录密码明文）

## 八、未来扩展功能

### 8.1 短期扩展（1-2个月）
1. **密码修改功能**：用户自主修改密码
2. **密码重置**：通过邮箱或短信重置密码
3. **多因素认证**：短信验证码/邮箱验证
4. **会话管理**：查看和管理活跃会话

### 8.2 中期扩展（3-6个月）
1. **单点登录（SSO）**：集成第三方认证
2. **LDAP/AD集成**：对接学校现有认证系统
3. **权限组管理**：灵活配置权限组
4. **审计日志**：完整的操作审计

### 8.3 长期扩展（6个月以上）
1. **OAuth 2.0支持**：第三方应用授权
2. **生物识别认证**：指纹/面部识别
3. **风险检测**：异常登录行为检测
4. **合规性认证**：满足教育行业安全标准

## 九、验收标准

### 9.1 功能验收
- [ ] 管理员可以使用admin/admin登录
- [ ] 普通用户可以使用用户名密码登录
- [ ] 登录失败显示友好错误信息
- [ ] 记住我功能正常工作
- [ ] 令牌过期后自动跳转登录页
- [ ] 不同角色看到不同的侧边栏菜单
- [ ] 无权限页面无法访问

### 9.2 性能验收
- [ ] 登录请求响应时间 < 500ms
- [ ] 令牌验证时间 < 10ms
- [ ] 支持并发登录（100用户/秒）

### 9.3 安全验收
- [ ] 密码哈希存储，无法逆向破解
- [ ] JWT令牌有效验证
- [ ] SQL注入防护
- [ ] XSS攻击防护
- [ ] 暴力破解防护（未来扩展）

## 十、附录

### 10.1 相关文件路径
- 数据库迁移：`backend/migrations/002_add_login_fields_to_persons.sql`
- 后端认证：`backend/src/core/auth.rs`、`backend/src/api/auth.rs`
- 前端登录：`frontend/src/views/LoginView.vue`
- 权限配置：`frontend/src/config/permissions.ts`
- 状态管理：`frontend/src/stores/user.ts`

### 10.2 环境变量配置
```env
# 后端环境变量
DATABASE_URL=postgresql://user:password@localhost:5432/school_management
JWT_SECRET=your-jwt-secret-key-change-in-production
JWT_EXPIRES_IN=24h

# 前端环境变量
VITE_API_BASE_URL=http://localhost:3000/api
```

### 10.3 测试账户
- 管理员：admin / admin
- 教师：teacher001 / 123456
- 学生：student001 / 123456
- 家长：parent001 / 123456

---
**文档版本**：v1.0  
**最后更新**：2026-02-24  
**负责人**：开发团队