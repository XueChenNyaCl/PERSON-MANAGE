# 人工智能模型集成开发文档

## 1. 项目概述

本文档描述了如何在现有项目中集成人工智能模型，实现一个AI对话功能，该功能能够根据用户的权限获取相应的信息并进行分析。

### 1.1 现有项目结构

- **前端**：Vue 3 + TypeScript + Pinia + Vue Router
- **后端**：Rust + Axum + SQLx + PostgreSQL
- **权限系统**：基于角色的权限控制（RBAC）

### 1.2 目标功能

1. 在前端添加一个新的AI对话页面到侧边栏
2. 实现与AI对话的基本功能
3. 开发后端接口，允许AI模型获取用户权限内的信息
4. 确保请求合规性，即AI只能获取用户有权限访问的信息

## 2. 前端开发

### 2.1 添加AI对话页面到侧边栏

#### 2.1.1 修改路由配置

修改 `frontend/src/router/index.ts` 文件，添加AI对话页面的路由：

```typescript
// 在dashboard的children数组中添加
{
  path: 'ai',
  name: 'ai',
  component: () => import('../views/AIView.vue')
},
{
  path: 'ai/settings',
  name: 'ai-settings',
  component: () => import('../views/AISettingsView.vue')
}

// 在重定向路由中添加
{
  path: '/ai',
  redirect: '/dashboard/ai'
},
{
  path: '/ai/settings',
  redirect: '/dashboard/ai/settings'
}
```

#### 2.1.2 修改菜单配置

修改 `frontend/src/config/menu.ts` 文件，添加AI对话和AI设置菜单项：

```typescript
// 在menuItems数组中添加
{
  id: 'ai',
  title: 'AI助手',
  icon: 'ChatLineRound',
  path: '/dashboard/ai',
  requiredPermission: 'ai.view',
  parentId: 'ai-management'
},
{
  id: 'ai-settings',
  title: 'AI设置',
  icon: 'Setting',
  path: '/dashboard/ai/settings',
  requiredPermission: 'system.settings', // 仅管理员可访问
  parentId: 'ai-management'
}

// 在menuGroups数组中添加
{
  id: 'ai-management',
  title: 'AI助手'
}
```

### 2.2 创建AI对话页面

创建 `frontend/src/views/AIView.vue` 文件：

### 2.4 创建AI设置页面

创建 `frontend/src/views/AISettingsView.vue` 文件：

```vue
<template>
  <div class="ai-settings-view">
    <div class="ai-settings-header">
      <h2>AI设置</h2>
      <p>管理AI模型的API配置和身份设置</p>
    </div>
    
    <el-tabs v-model="activeTab">
      <!-- API设置 -->
      <el-tab-pane label="API设置" name="api">
        <div class="settings-form">
          <el-form :model="settings" label-width="120px">
            <el-form-item label="API Key">
              <el-input 
                v-model="settings.api_key" 
                type="password" 
                placeholder="请输入API Key"
              />
            </el-form-item>
            <el-form-item label="模型">
              <el-select v-model="settings.model" placeholder="请选择模型">
                <el-option label="gpt-3.5-turbo" value="gpt-3.5-turbo" />
                <el-option label="gpt-4" value="gpt-4" />
              </el-select>
            </el-form-item>
            <el-form-item label="温度">
              <el-slider 
                v-model="settings.temperature" 
                :min="0" 
                :max="1" 
                :step="0.1"
              />
              <span class="slider-value">{{ settings.temperature }}</span>
            </el-form-item>
            <el-form-item label="最大 token">
              <el-input-number 
                v-model="settings.max_tokens" 
                :min="100" 
                :max="4000" 
                :step="100"
              />
            </el-form-item>
            <el-form-item label="默认提示词">
              <el-input 
                v-model="settings.default_prompt" 
                type="textarea" 
                :rows="4" 
                placeholder="请输入默认提示词"
              />
            </el-form-item>
            <el-form-item>
              <el-button type="primary" @click="saveSettings">保存设置</el-button>
            </el-form-item>
          </el-form>
        </div>
      </el-tab-pane>
      
      <!-- 身份管理 -->
      <el-tab-pane label="身份管理" name="identities">
        <div class="identities-management">
          <el-button type="primary" @click="dialogVisible = true" style="margin-bottom: 20px">
            <el-icon><Plus /></el-icon> 创建身份
          </el-button>
          
          <el-table :data="identities" style="width: 100%">
            <el-table-column prop="name" label="名称" width="180" />
            <el-table-column prop="description" label="描述" />
            <el-table-column prop="is_active" label="状态" width="100">
              <template #default="scope">
                <el-tag :type="scope.row.is_active ? 'success' : 'danger'">
                  {{ scope.row.is_active ? '启用' : '禁用' }}
                </el-tag>
              </template>
            </el-table-column>
            <el-table-column label="操作" width="200">
              <template #default="scope">
                <el-button size="small" @click="editIdentity(scope.row)">
                  <el-icon><Edit /></el-icon> 编辑
                </el-button>
                <el-button size="small" type="danger" @click="deleteIdentity(scope.row.id)">
                  <el-icon><Delete /></el-icon> 删除
                </el-button>
              </template>
            </el-table-column>
          </el-table>
        </div>
      </el-tab-pane>
    </el-tabs>
    
    <!-- 创建/编辑身份对话框 -->
    <el-dialog
      v-model="dialogVisible"
      :title="dialogTitle"
      width="600px"
    >
      <el-form :model="identityForm" label-width="100px">
        <el-form-item label="名称">
          <el-input v-model="identityForm.name" placeholder="请输入身份名称" />
        </el-form-item>
        <el-form-item label="描述">
          <el-input 
            v-model="identityForm.description" 
            type="textarea" 
            :rows="2" 
            placeholder="请输入身份描述"
          />
        </el-form-item>
        <el-form-item label="提示词">
          <el-input 
            v-model="identityForm.prompt" 
            type="textarea" 
            :rows="4" 
            placeholder="请输入身份提示词"
          />
        </el-form-item>
        <el-form-item label="允许的角色">
          <el-checkbox-group v-model="identityForm.allowed_roles">
            <el-checkbox label="admin">管理员</el-checkbox>
            <el-checkbox label="teacher">教师</el-checkbox>
            <el-checkbox label="student">学生</el-checkbox>
            <el-checkbox label="parent">家长</el-checkbox>
          </el-checkbox-group>
        </el-form-item>
        <el-form-item label="状态">
          <el-switch v-model="identityForm.is_active" />
        </el-form-item>
      </el-form>
      <template #footer>
        <span class="dialog-footer">
          <el-button @click="dialogVisible = false">取消</el-button>
          <el-button type="primary" @click="saveIdentity">保存</el-button>
        </span>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useAuthStore } from '../store/auth'
import { api } from '../api'
import { Plus, Edit, Delete } from '@element-plus/icons-vue'

const authStore = useAuthStore()

// 标签页
const activeTab = ref('api')

// API设置
const settings = ref({
  api_key: '',
  model: 'gpt-3.5-turbo',
  temperature: 0.7,
  max_tokens: 1000,
  default_prompt: 'You are an AI assistant for a school management system.'
})

// 身份列表
const identities = ref<any[]>([])

// 对话框状态
const dialogVisible = ref(false)
const dialogTitle = ref('创建身份')
const editingIdentityId = ref<string>('')

// 身份表单
const identityForm = ref({
  name: '',
  description: '',
  prompt: '',
  allowed_roles: [] as string[],
  is_active: true
})

// 加载设置
const loadSettings = async () => {
  try {
    const response = await api.ai.getSettings()
    settings.value = response.data
  } catch (error) {
    console.error('Error loading settings:', error)
  }
}

// 保存设置
const saveSettings = async () => {
  try {
    await api.ai.updateSettings(settings.value)
    ElMessage.success('设置保存成功')
  } catch (error) {
    console.error('Error saving settings:', error)
    ElMessage.error('保存设置失败')
  }
}

// 加载身份列表
const loadIdentities = async () => {
  try {
    const response = await api.ai.listIdentities()
    identities.value = response.data
  } catch (error) {
    console.error('Error loading identities:', error)
  }
}

// 打开创建身份对话框
const openCreateDialog = () => {
  dialogTitle.value = '创建身份'
  editingIdentityId.value = ''
  identityForm.value = {
    name: '',
    description: '',
    prompt: '',
    allowed_roles: [],
    is_active: true
  }
  dialogVisible.value = true
}

// 打开编辑身份对话框
const editIdentity = (identity: any) => {
  dialogTitle.value = '编辑身份'
  editingIdentityId.value = identity.id
  identityForm.value = {
    name: identity.name,
    description: identity.description,
    prompt: identity.prompt,
    allowed_roles: identity.allowed_roles,
    is_active: identity.is_active
  }
  dialogVisible.value = true
}

// 保存身份
const saveIdentity = async () => {
  try {
    if (editingIdentityId.value) {
      // 更新身份
      await api.ai.updateIdentity(editingIdentityId.value, identityForm.value)
      ElMessage.success('身份更新成功')
    } else {
      // 创建身份
      await api.ai.createIdentity(identityForm.value)
      ElMessage.success('身份创建成功')
    }
    dialogVisible.value = false
    loadIdentities()
  } catch (error) {
    console.error('Error saving identity:', error)
    ElMessage.error('保存身份失败')
  }
}

// 删除身份
const deleteIdentity = async (id: string) => {
  try {
    await api.ai.deleteIdentity(id)
    ElMessage.success('身份删除成功')
    loadIdentities()
  } catch (error) {
    console.error('Error deleting identity:', error)
    ElMessage.error('删除身份失败')
  }
}

// 初始化
onMounted(() => {
  loadSettings()
  loadIdentities()
})
</script>

<style scoped>
.ai-settings-view {
  padding: 20px;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.ai-settings-header {
  margin-bottom: 20px;
}

.ai-settings-header h2 {
  font-size: 24px;
  margin-bottom: 8px;
  color: #333;
}

.ai-settings-header p {
  font-size: 14px;
  color: #666;
}

.settings-form {
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
}

.slider-value {
  margin-left: 10px;
  font-size: 14px;
  color: #666;
}

.identities-management {
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
}

.dialog-footer {
  display: flex;
  justify-content: flex-end;
}
</style>
```

## 4. 可能出现的bug及预防措施

根据 `x:\works\code\ccccc\docs\注意事项和错误修复指南.md` 文档，以下是集成AI模型时可能出现的bug及预防措施：

### 4.1 数据库连接问题

**可能的bug**：
- AI API无法连接数据库，导致权限检查失败
- 数据库连接池初始化失败，影响AI设置的保存和读取

**预防措施**：
- 在AI API处理函数中添加数据库连接检查
- 实现优雅降级，当数据库不可用时返回合适的错误信息
- 参考 `注意事项和错误修复指南.md` 中的数据库连接失败处理方案

### 4.2 API响应结构问题

**可能的bug**：
- 前端代码直接访问 `response.items` 而非 `response.data.items`
- API返回结构与前端期望不匹配，导致前端解析错误

**预防措施**：
- 确保所有前端API调用正确访问 `response.data`
- 使用TypeScript类型定义确保API响应结构的一致性
- 参考 `注意事项和错误修复指南.md` 中的前端API响应结构修复方案

### 4.3 权限控制问题

**可能的bug**：
- 管理员权限检查逻辑错误，导致非管理员用户访问AI设置页面
- 权限字符串不一致，导致权限检查失败

**预防措施**：
- 严格按照 `注意事项和错误修复指南.md` 中的权限管理实现
- 确保前端菜单项的 `requiredPermission` 与后端权限名称一致
- 添加权限检查的单元测试

### 4.4 API密钥安全问题

**可能的bug**：
- API密钥硬编码在代码中，存在安全风险
- API密钥传输过程中未加密，可能被拦截

**预防措施**：
- 将API密钥存储在环境变量中，避免硬编码
- 使用HTTPS确保API密钥传输安全
- 定期轮换API密钥

### 4.5 输入验证问题

**可能的bug**：
- 用户输入未经过验证，导致注入攻击
- 输入数据格式错误，导致后端处理失败

**预防措施**：
- 对所有用户输入进行验证，特别是AI提示词
- 参考 `注意事项和错误修复指南.md` 中的数据清理方案
- 使用serde进行严格的类型检查

### 4.6 性能问题

**可能的bug**：
- AI模型调用响应时间过长，影响用户体验
- 并发请求过多，导致系统负载过高

**预防措施**：
- 实现请求频率限制，防止滥用
- 使用异步处理长时间运行的AI任务
- 考虑添加缓存机制，减少重复请求

## 5. 总结

本开发文档详细描述了如何在现有项目中集成人工智能模型，实现一个基于用户权限的AI对话功能，并添加了管理员设置API的功能。通过前端添加新页面，后端实现API接口，以及集成AI模型，我们可以为用户提供一个智能的助手，帮助他们分析和获取有权限访问的信息。

主要功能包括：
1. **AI对话页面**：用户可以与AI助手进行对话，获取权限范围内的信息
2. **AI设置页面**：管理员可以配置AI模型的API密钥、模型参数和创建AI身份
3. **身份管理**：管理员可以创建不同的AI身份，并指定哪些角色可以使用这些身份
4. **权限控制**：确保AI只能获取用户有权限访问的信息，管理员才能修改AI设置

在实现过程中，我们需要确保：
1. 权限控制的正确性，确保AI只能获取用户有权限的信息
2. 系统的安全性，防止API密钥泄露和滥用
3. 良好的用户体验，提供直观的对话界面和设置界面
4. 系统的可扩展性，方便未来添加更多功能

通过本方案，我们可以为学校管理系统添加智能助手功能，提高用户的工作效率和系统的整体价值。
    // 目前使用简单的模拟回复
    let response = format!("我收到了您的消息: {}", req.message);
    
    Ok(Json(ChatResponse {
        data: response,
    }))
}

// 获取班级信息
pub async fn get_class_info(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
) -> Result<Json<ClassInfoResponse>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查用户权限
    let permission_manager = PermissionManager::new(pool.clone());
    if !permission_manager.check_permission(claims.sub, "class.view").await == crate::core::permission::PermissionResult::Allowed {
        return Err(axum::http::StatusCode::FORBIDDEN);
    }
    
    // 获取班级信息
    let class_info = class::get(&pool, id).await
        .map_err(|_| axum::http::StatusCode::NOT_FOUND)?;
    
    // 获取学生数量
    let students_count = sqlx::query_scalar!("SELECT COUNT(*) FROM person_class WHERE class_id = $1 AND role = 'student'", id)
        .fetch_one(&pool)
        .await
        .unwrap_or(0);
    
    // 获取教师数量
    let teachers_count = sqlx::query_scalar!("SELECT COUNT(*) FROM person_class WHERE class_id = $1 AND role = 'teacher'", id)
        .fetch_one(&pool)
        .await
        .unwrap_or(0);
    
    Ok(Json(ClassInfoResponse {
        id: class_info.id,
        name: class_info.name,
        grade: class_info.grade,
        students_count,
        teachers_count,
    }))
}

// 获取小组信息
pub async fn get_group_info(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
) -> Result<Json<GroupInfoResponse>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查用户权限
    let permission_manager = PermissionManager::new(pool.clone());
    if !permission_manager.check_permission(claims.sub, "group.view").await == crate::core::permission::PermissionResult::Allowed {
        return Err(axum::http::StatusCode::FORBIDDEN);
    }
    
    // 获取小组信息
    let group_info = group::get(&pool, id).await
        .map_err(|_| axum::http::StatusCode::NOT_FOUND)?;
    
    // 获取成员数量
    let members_count = sqlx::query_scalar!("SELECT COUNT(*) FROM group_members WHERE group_id = $1", id)
        .fetch_one(&pool)
        .await
        .unwrap_or(0);
    
    // 获取平均分数
    let average_score = sqlx::query_scalar!("SELECT AVG(score) FROM group_score_records WHERE group_id = $1", id)
        .fetch_one(&pool)
        .await
        .ok();
    
    Ok(Json(GroupInfoResponse {
        id: group_info.id,
        name: group_info.name,
        class_id: group_info.class_id,
        members_count,
        average_score,
    }))
}

// 获取部门信息
pub async fn get_department_info(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
) -> Result<Json<DepartmentInfoResponse>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查用户权限
    let permission_manager = PermissionManager::new(pool.clone());
    if !permission_manager.check_permission(claims.sub, "department.view").await == crate::core::permission::PermissionResult::Allowed {
        return Err(axum::http::StatusCode::FORBIDDEN);
    }
    
    // 获取部门信息
    let dept_info = department::get(&pool, id).await
        .map_err(|_| axum::http::StatusCode::NOT_FOUND)?;
    
    // 获取教师数量
    let teachers_count = sqlx::query_scalar!("SELECT COUNT(*) FROM persons WHERE department_id = $1 AND role = 'teacher'", id)
        .fetch_one(&pool)
        .await
        .unwrap_or(0);
    
    Ok(Json(DepartmentInfoResponse {
        id: dept_info.id,
        name: dept_info.name,
        description: dept_info.description,
        teachers_count,
    }))
}

// 获取AI设置
pub async fn get_settings(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
) -> Result<Json<AISettings>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查是否为管理员
    check_admin(&claims, &pool).await?;
    
    // 从数据库获取设置（这里使用默认值作为示例）
    let settings = AISettings {
        api_key: "sk-...", // 实际应该从数据库或配置文件获取
        model: "gpt-3.5-turbo",
        temperature: 0.7,
        max_tokens: 1000,
        default_prompt: "You are an AI assistant for a school management system.",
    };
    
    Ok(Json(settings))
}

// 更新AI设置
pub async fn update_settings(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Json(settings): Json<AISettings>,
) -> Result<Json<AISettings>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查是否为管理员
    check_admin(&claims, &pool).await?;
    
    // 保存设置到数据库（这里只是示例）
    // 实际应该将设置保存到数据库或配置文件
    
    Ok(Json(settings))
}

// 列出AI身份
pub async fn list_identities(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
) -> Result<Json<Vec<AIIdentity>>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查是否为管理员
    check_admin(&claims, &pool).await?;
    
    // 从数据库获取身份列表（这里使用默认值作为示例）
    let identities = vec![
        AIIdentity {
            id: Uuid::new_v4(),
            name: "默认助手",
            description: "通用的学校管理系统助手",
            prompt: "You are an AI assistant for a school management system.",
            allowed_roles: vec!["admin", "teacher", "student", "parent"],
            is_active: true,
        },
    ];
    
    Ok(Json(identities))
}

// 创建AI身份
pub async fn create_identity(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Json(req): Json<CreateIdentityRequest>,
) -> Result<Json<AIIdentity>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查是否为管理员
    check_admin(&claims, &pool).await?;
    
    // 创建新身份
    let identity = AIIdentity {
        id: Uuid::new_v4(),
        name: req.name,
        description: req.description,
        prompt: req.prompt,
        allowed_roles: req.allowed_roles,
        is_active: req.is_active,
    };
    
    // 保存到数据库
    // 实际应该将身份保存到数据库
    
    Ok(Json(identity))
}

// 更新AI身份
pub async fn update_identity(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
    Json(req): Json<UpdateIdentityRequest>,
) -> Result<Json<AIIdentity>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查是否为管理员
    check_admin(&claims, &pool).await?;
    
    // 从数据库获取身份
    // 实际应该从数据库获取
    let mut identity = AIIdentity {
        id,
        name: "默认助手",
        description: "通用的学校管理系统助手",
        prompt: "You are an AI assistant for a school management system.",
        allowed_roles: vec!["admin", "teacher", "student", "parent"],
        is_active: true,
    };
    
    // 更新字段
    if let Some(name) = req.name {
        identity.name = name;
    }
    if let Some(description) = req.description {
        identity.description = description;
    }
    if let Some(prompt) = req.prompt {
        identity.prompt = prompt;
    }
    if let Some(allowed_roles) = req.allowed_roles {
        identity.allowed_roles = allowed_roles;
    }
    if let Some(is_active) = req.is_active {
        identity.is_active = is_active;
    }
    
    // 保存到数据库
    // 实际应该将更新后的身份保存到数据库
    
    Ok(Json(identity))
}

// 删除AI身份
pub async fn delete_identity(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
) -> Result<Json<serde_json::Value>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 检查是否为管理员
    check_admin(&claims, &pool).await?;
    
    // 从数据库删除身份
    // 实际应该从数据库删除
    
    Ok(Json(serde_json::json!({"message": "Identity deleted successfully"})))
}
```

### 3.3 修改API模块导出

修改 `backend/src/api/mod.rs` 文件，添加AI模块的导出：

```rust
pub mod ai;
```

### 3.4 添加AI权限

在权限模板文件中添加AI相关的权限，例如在 `backend/templates/permissions/admin.yaml` 中添加：

```yaml
permissions:
  # 其他权限...
  - permission: "ai.view"
    priority: 15
  - permission: "ai.chat"
    priority: 15
  - permission: "ai.analyze"
    priority: 15
```

## 4. 集成AI模型

### 4.1 选择AI模型

可以选择以下AI模型之一进行集成：

1. **OpenAI GPT**：通过API调用
2. **Hugging Face模型**：可以部署本地或通过API调用
3. **开源模型**：如Llama 2、Falcon等，可部署本地

### 4.2 实现AI模型集成

以OpenAI GPT为例，修改 `backend/src/api/ai.rs` 文件：

```rust
use reqwest::Client;

// 在chat函数中添加
pub async fn chat(
    State(state): State<crate::api::routes::AppState>,
    Extension(claims): Extension<Claims>,
    Json(req): Json<ChatRequest>,
) -> Result<Json<ChatResponse>, axum::http::StatusCode> {
    let pool = state.pool.ok_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    // 构建AI提示词，包含用户权限信息
    let permission_manager = PermissionManager::new(pool.clone());
    let user_permissions = permission_manager.get_user_permissions_list(claims.sub).await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let permissions_str = user_permissions.join(", ");
    
    let prompt = format!(
        "You are an AI assistant for a school management system. The user has the following permissions: {}. 
        Please answer the user's question based on their permissions. If they ask for information they don't have permission to access, 
        politely decline.\n\nUser's question: {}",
        permissions_str,
        req.message
    );
    
    // 调用OpenAI API
    let client = Client::new();
    let response = client
        .post("https://api.openai.com/v1/chat/completions")
        .header("Authorization", format!("Bearer {}", "YOUR_OPENAI_API_KEY"))
        .json(&serde_json::json!({
            "model": "gpt-3.5-turbo",
            "messages": [
                {"role": "system", "content": "You are an AI assistant for a school management system."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.7
        }))
        .send()
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let response_data: serde_json::Value = response
        .json()
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let ai_response = response_data["choices"][0]["message"]["content"]
        .as_str()
        .unwrap_or("I'm sorry, I couldn't process your request.")
        .to_string();
    
    Ok(Json(ChatResponse {
        data: ai_response,
    }))
}
```

### 4.3 安全考虑

1. **API密钥管理**：将API密钥存储在环境变量中，不要硬编码
2. **请求频率限制**：添加请求频率限制，防止滥用
3. **输入验证**：对用户输入进行验证，防止注入攻击
4. **响应过滤**：确保AI响应不包含敏感信息

## 5. 测试和部署

### 5.1 前端测试

1. 运行前端开发服务器：`npm run dev`
2. 登录系统，检查侧边栏是否显示AI助手菜单项
3. 点击AI助手，进入对话页面
4. 发送消息，测试对话功能
5. 测试权限控制，确保AI只能获取用户有权限的信息

### 5.2 后端测试

1. 运行后端开发服务器：`cargo run`
2. 使用API工具（如Postman）测试AI相关的API接口
3. 测试权限控制，确保未授权用户无法访问API

### 5.3 部署

1. 构建前端：`npm run build`
2. 构建后端：`cargo build --release`
3. 部署到生产环境
4. 配置环境变量，包括数据库连接信息和AI API密钥

## 6. 扩展功能

### 6.1 可能的扩展

1. **更丰富的AI功能**：
   - 数据分析和可视化
   - 自动生成报表
   - 智能推荐

2. **多语言支持**：
   - 支持多语言对话
   - 自动翻译功能

3. **个性化设置**：
   - 允许用户自定义AI助手的行为
   - 保存对话历史

### 6.2 性能优化

1. **缓存**：缓存频繁访问的数据
2. **异步处理**：使用异步处理长时间运行的任务
3. **模型优化**：使用适合部署环境的AI模型

## 7. 总结

本开发文档详细描述了如何在现有项目中集成人工智能模型，实现一个基于用户权限的AI对话功能。通过前端添加新页面，后端实现API接口，以及集成AI模型，我们可以为用户提供一个智能的助手，帮助他们分析和获取有权限访问的信息。

在实现过程中，我们需要确保：
1. 权限控制的正确性，确保AI只能获取用户有权限的信息
2. 系统的安全性，防止滥用和攻击
3. 良好的用户体验，提供直观的对话界面
4. 系统的可扩展性，方便未来添加更多功能

通过本方案，我们可以为学校管理系统添加智能助手功能，提高用户的工作效率和系统的整体价值。