人员管理模块开发计划
1. 模块概述
人员管理模块负责维护学校系统中的所有人员信息，包括学生、教职工、家长，以及相关的班级和部门组织。该模块是系统的核心基础，为考勤、评分、通知等其它模块提供人员数据支持。

1.1 功能列表
学生管理：增删改查，支持批量导入/导出 Excel，分配班级，关联家长。

教职工管理：增删改查，支持批量导入/导出 Excel，分配部门，设置职位。

家长管理：增删改查，关联学生，维护联系方式。

班级管理：增删改查，设置班主任，年级分类。

部门管理：增删改查（教务处、德育处等）。

人员搜索：支持按姓名、学号/工号、班级/部门模糊搜索，分页展示。

人员详情：展示完整档案，包括关联的班级、部门、家长/孩子信息。

权限预留：虽然第一期不实现权限控制，但数据模型和 API 设计需预留角色字段，方便后续集成 RBAC。

2. 数据模型设计
2.1 数据库表结构
2.1.1 persons 表（人员基础信息）
sql
CREATE TABLE persons (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL,
    gender SMALLINT NOT NULL DEFAULT 0, -- 0:未知 1:男 2:女
    birthday DATE,
    phone VARCHAR(20),
    email VARCHAR(100),
    type VARCHAR(20) NOT NULL, -- 'student', 'teacher', 'parent'
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
2.1.2 students 表（学生扩展信息）
sql
CREATE TABLE students (
    person_id UUID PRIMARY KEY REFERENCES persons(id) ON DELETE CASCADE,
    student_no VARCHAR(50) UNIQUE NOT NULL,
    class_id UUID REFERENCES classes(id) ON DELETE SET NULL,
    enrollment_date DATE,
    status VARCHAR(20) DEFAULT 'enrolled' -- enrolled, graduated, transferred
);
2.1.3 teachers 表（教职工扩展信息）
sql
CREATE TABLE teachers (
    person_id UUID PRIMARY KEY REFERENCES persons(id) ON DELETE CASCADE,
    employee_no VARCHAR(50) UNIQUE NOT NULL,
    department_id UUID REFERENCES departments(id) ON DELETE SET NULL,
    title VARCHAR(50), -- 职称（高级教师、一级教师等）
    hire_date DATE
);
2.1.4 parents 表（家长扩展信息）
sql
CREATE TABLE parents (
    person_id UUID PRIMARY KEY REFERENCES persons(id) ON DELETE CASCADE,
    wechat_openid VARCHAR(100), -- 可选，用于推送
    occupation VARCHAR(100)
);
2.1.5 student_parent 关联表（学生-家长关系）
sql
CREATE TABLE student_parent (
    student_id UUID REFERENCES students(person_id) ON DELETE CASCADE,
    parent_id UUID REFERENCES parents(person_id) ON DELETE CASCADE,
    relationship VARCHAR(20), -- father, mother, guardian
    PRIMARY KEY (student_id, parent_id)
);
2.1.6 classes 表（班级）
sql
CREATE TABLE classes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL,
    grade SMALLINT NOT NULL, -- 年级，如 1 表示一年级
    teacher_id UUID REFERENCES teachers(person_id) ON DELETE SET NULL, -- 班主任
    academic_year VARCHAR(20), -- 学年，如 "2025-2026"
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
2.1.7 departments 表（部门）
sql
CREATE TABLE departments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL,
    parent_id UUID REFERENCES departments(id) ON DELETE CASCADE, -- 支持部门树
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
2.2 索引设计
sql
-- 加速搜索
CREATE INDEX idx_persons_name ON persons(name);
CREATE INDEX idx_persons_type ON persons(type);
CREATE INDEX idx_students_student_no ON students(student_no);
CREATE INDEX idx_teachers_employee_no ON teachers(employee_no);
CREATE INDEX idx_students_class_id ON students(class_id);
CREATE INDEX idx_teachers_department_id ON teachers(department_id);
3. 后端 API 设计
3.1 基础规范
基础路径：/api/v1

请求/响应格式：JSON

认证：暂不实现，但预留 Authorization 头

分页：所有列表接口支持 page（从1开始）和 limit 参数，默认 page=1, limit=20

搜索：支持 q 参数进行模糊搜索（姓名、学号/工号）

3.2 人员管理 API
3.2.1 获取人员列表
GET /persons

查询参数：

type：可选，过滤类型（student/teacher/parent）

q：可选，搜索关键字

class_id：可选，仅当type=student时有效

department_id：可选，仅当type=teacher时有效

page、limit

响应：

json
{
  "total": 100,
  "page": 1,
  "limit": 20,
  "items": [
    {
      "id": "uuid",
      "name": "张三",
      "gender": 1,
      "birthday": "2010-01-01",
      "phone": "13800138000",
      "email": "zhangsan@example.com",
      "type": "student",
      "student_no": "2025001",
      "class_id": "uuid",
      "class_name": "高一(1)班"
    },
    // ...
  ]
}
3.2.2 获取单个人员
GET /persons/{id}

响应：包含所有扩展字段的完整对象。

3.2.3 创建人员
POST /persons

请求体（以学生为例）：

json
{
  "type": "student",
  "name": "李四",
  "gender": 2,
  "birthday": "2011-02-02",
  "phone": "13900139000",
  "email": "lisi@example.com",
  "student_no": "2025002",
  "class_id": "uuid"
}
响应：201 Created，返回创建的对象。

3.2.4 更新人员
PUT /persons/{id}

请求体同创建，需包含所有字段（或部分字段？建议支持 PATCH，但此处用 PUT 全量更新）。

3.2.5 删除人员
DELETE /persons/{id}

3.2.6 批量导入
POST /persons/import

Content-Type: multipart/form-data

文件字段：file（Excel 文件）

返回导入结果统计（成功数、失败数、错误详情）

3.2.7 批量导出
GET /persons/export?type=student&q=...
返回 Excel 文件流。

3.3 班级管理 API
3.3.1 获取班级列表
GET /classes 支持分页和搜索（班级名、年级）。

3.3.2 获取单个班级
GET /classes/{id}

3.3.3 创建/更新/删除班级
类似人员接口。

3.4 部门管理 API
类似班级接口。

4. 后端实现细节
4.1 技术栈
框架：Axum

数据库：SQLx (PostgreSQL)

序列化：serde

分页：手动实现 limit/offset

导入导出：rust-excel 或 calamine 读取，xlsx 写入

4.2 核心数据结构和函数
4.2.1 人员统一数据结构（用于 API 响应）
rust
use serde::{Serialize, Deserialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum PersonResponse {
    Student(StudentResponse),
    Teacher(TeacherResponse),
    Parent(ParentResponse),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct StudentResponse {
    pub id: Uuid,
    pub name: String,
    pub gender: i16,
    pub birthday: Option<chrono::NaiveDate>,
    pub phone: Option<String>,
    pub email: Option<String>,
    pub student_no: String,
    pub class_id: Option<Uuid>,
    pub class_name: Option<String>,
}

// 类似定义 TeacherResponse, ParentResponse
4.2.2 数据库查询函数
获取人员列表（支持过滤和搜索）

rust
pub async fn list_persons(
    pool: &sqlx::PgPool,
    person_type: Option<&str>,
    search: Option<&str>,
    class_id: Option<Uuid>,
    dept_id: Option<Uuid>,
    page: i64,
    limit: i64,
) -> Result<(Vec<PersonResponse>, i64), sqlx::Error> {
    let offset = (page - 1) * limit;
    
    // 构建基础查询
    let mut count_query = String::from("SELECT COUNT(*) FROM persons p ");
    let mut data_query = String::from("
        SELECT 
            p.id, p.name, p.gender, p.birthday, p.phone, p.email, p.type,
            s.student_no, s.class_id, c.name as class_name,
            t.employee_no, t.department_id, d.name as department_name,
            -- 家长字段略
        FROM persons p
        LEFT JOIN students s ON p.id = s.person_id AND p.type = 'student'
        LEFT JOIN classes c ON s.class_id = c.id
        LEFT JOIN teachers t ON p.id = t.person_id AND p.type = 'teacher'
        LEFT JOIN departments d ON t.department_id = d.id
        -- 家长左连接略
        WHERE 1=1
    ");
    
    let mut conditions = Vec::new();
    let mut params = Vec::new();
    
    if let Some(typ) = person_type {
        conditions.push("p.type = $".to_string() + &(params.len()+1).to_string());
        params.push(typ);
    }
    if let Some(q) = search {
        // 使用 PostgreSQL 的全文搜索或 LIKE
        conditions.push("(p.name ILIKE $".to_string() + &(params.len()+1).to_string() + 
                        " OR s.student_no ILIKE $" + &(params.len()+2).to_string() + 
                        " OR t.employee_no ILIKE $" + &(params.len()+3).to_string() + ")");
        let pattern = format!("%{}%", q);
        params.push(pattern.clone());
        params.push(pattern.clone());
        params.push(pattern);
    }
    if let Some(cid) = class_id {
        conditions.push("s.class_id = $".to_string() + &(params.len()+1).to_string());
        params.push(cid);
    }
    if let Some(did) = dept_id {
        conditions.push("t.department_id = $".to_string() + &(params.len()+1).to_string());
        params.push(did);
    }
    
    if !conditions.is_empty() {
        let where_clause = " AND ".join(&conditions);
        count_query.push_str(" WHERE ");
        count_query.push_str(&where_clause);
        data_query.push_str(" WHERE ");
        data_query.push_str(&where_clause);
    }
    
    // 执行 count 查询
    let total: i64 = sqlx::query_scalar(&count_query)
        .bind_all(params.clone())
        .fetch_one(pool)
        .await?;
    
    // 添加排序和分页
    data_query.push_str(" ORDER BY p.created_at DESC LIMIT $").push_str(&(params.len()+1).to_string());
    data_query.push_str(" OFFSET $").push_str(&(params.len()+2).to_string());
    params.push(limit);
    params.push(offset);
    
    // 执行数据查询并映射到 PersonResponse
    let rows = sqlx::query_as::<_, PersonRow>(&data_query)
        .bind_all(params)
        .fetch_all(pool)
        .await?;
    
    let items = rows.into_iter().map(|row| row.into_response()).collect();
    Ok((items, total))
}
4.2.3 创建人员的事务处理
由于人员类型不同，需要同时插入 persons 表和对应的扩展表，应使用事务。

rust
pub async fn create_person(
    pool: &sqlx::PgPool,
    payload: CreatePersonPayload,
) -> Result<PersonResponse, AppError> {
    let mut tx = pool.begin().await?;
    
    // 插入 persons 表
    let person_id = sqlx::query_scalar::<_, Uuid>(
        "INSERT INTO persons (name, gender, birthday, phone, email, type) 
         VALUES ($1, $2, $3, $4, $5, $6) RETURNING id"
    )
    .bind(&payload.name)
    .bind(payload.gender)
    .bind(payload.birthday)
    .bind(&payload.phone)
    .bind(&payload.email)
    .bind(&payload.person_type)
    .fetch_one(&mut *tx)
    .await?;
    
    // 根据类型插入扩展表
    match payload {
        CreatePersonPayload::Student { student_no, class_id, .. } => {
            sqlx::query(
                "INSERT INTO students (person_id, student_no, class_id) VALUES ($1, $2, $3)"
            )
            .bind(person_id)
            .bind(student_no)
            .bind(class_id)
            .execute(&mut *tx)
            .await?;
        }
        // 其他类型类似
    }
    
    tx.commit().await?;
    
    // 返回完整人员信息
    get_person(pool, person_id).await
}
4.2.4 导入导出实现
导入：使用 calamine 读取 Excel，逐行验证并插入，返回统计结果。

导出：使用 rust_xlsxwriter 创建 Excel 文件，写入查询结果，作为响应流。

4.3 错误处理
自定义 AppError 枚举，涵盖数据库错误、验证错误、未找到等，并实现 IntoResponse 返回统一 JSON 错误格式。

5. 前端设计
5.1 页面路由
typescript
// router/index.ts
const routes = [
  {
    path: '/persons',
    component: PersonLayout,
    children: [
      { path: '', component: PersonList, name: 'person.list' },
      { path: 'create', component: PersonForm, name: 'person.create' },
      { path: ':id/edit', component: PersonForm, name: 'person.edit' },
      { path: ':id', component: PersonDetail, name: 'person.detail' },
    ]
  },
  { path: '/classes', component: ClassList },
  { path: '/departments', component: DepartmentList },
]
5.2 状态管理（Pinia）
typescript
// stores/person.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { Person, PersonQuery } from '@/types/person'
import { listPersons, createPerson, updatePerson, deletePerson } from '@/api/person'

export const usePersonStore = defineStore('person', () => {
  const persons = ref<Person[]>([])
  const total = ref(0)
  const loading = ref(false)
  const currentQuery = ref<PersonQuery>({ page: 1, limit: 20 })

  async function fetchPersons(query?: PersonQuery) {
    loading.value = true
    try {
      const res = await listPersons({ ...currentQuery.value, ...query })
      persons.value = res.items
      total.value = res.total
      if (query) currentQuery.value = { ...currentQuery.value, ...query }
    } finally {
      loading.value = false
    }
  }

  // 增删改类似
  return { persons, total, loading, fetchPersons }
})
5.3 API 调用封装
typescript
// api/person.ts
import request from '@/utils/request'
import type { Person, PersonQuery, ListResponse } from '@/types'

export function listPersons(params: PersonQuery) {
  return request.get<ListResponse<Person>>('/persons', { params })
}

export function getPerson(id: string) {
  return request.get<Person>(`/persons/${id}`)
}

export function createPerson(data: Partial<Person>) {
  return request.post<Person>('/persons', data)
}

// 导入导出
export function importPersons(file: File) {
  const formData = new FormData()
  formData.append('file', file)
  return request.post('/persons/import', formData, {
    headers: { 'Content-Type': 'multipart/form-data' }
  })
}

export function exportPersons(params: PersonQuery) {
  return request.get('/persons/export', { params, responseType: 'blob' })
}
5.4 组件结构
PersonList.vue：搜索表单、表格、分页、导入导出按钮

PersonForm.vue：表单，根据 type 动态显示不同字段（使用 v-if）

PersonDetail.vue：展示详情，包含关联信息

通用组件：SearchForm、DataTable、UploadButton

5.5 关键界面设计
列表页采用卡片式表格，每行显示姓名、类型、学号/工号、班级/部门，操作按钮（编辑、删除）。

搜索框支持实时输入防抖，按回车或点击搜索按钮触发。

新建/编辑表单使用抽屉或模态框，减少页面跳转。

6. 关键算法
6.1 模糊搜索算法
使用 PostgreSQL 的 ILIKE 配合索引，或者使用 pg_trgm 扩展进行相似度搜索。在用户输入时，前端可添加防抖（500ms）避免频繁请求。

sql
-- 启用 trigram 扩展（需要超级用户权限）
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 创建 GIN 索引
CREATE INDEX idx_persons_name_trgm ON persons USING gin (name gin_trgm_ops);
查询时使用 name % $1 进行相似度匹配，或 ILIKE 加前后通配符。

6.2 权限过滤（预留）
未来可根据当前登录用户角色，自动在查询中加入班级/部门过滤。可在 API 层通过中间件获取用户信息，动态修改 SQL。

7. 数据库连接与迁移
7.1 连接池配置（Rust）
rust
// src/core/db.rs
use sqlx::postgres::{PgPool, PgPoolOptions};

pub async fn create_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {
    PgPoolOptions::new()
        .max_connections(20)
        .connect(database_url)
        .await
}
7.2 数据库迁移
使用 sqlx migrate 管理版本。创建迁移文件：

bash
sqlx migrate add create_persons_tables
在 migrations/ 目录下生成 SQL 文件，编写上述建表语句。

在应用启动时自动运行迁移：

rust
sqlx::migrate!().run(&pool).await?;
8. 开发步骤（分阶段）
第一阶段：基础框架与数据模型（1周）
设计并创建数据库表

编写数据库迁移

搭建 Rust 项目结构，配置 Axum 和 SQLx

实现人员列表 API（不带过滤和搜索）

实现简单的创建 API（只支持学生）

前端搭建项目，实现人员列表展示页

第二阶段：核心 CRUD 与搜索（1周）
完成所有类型人员的创建、更新、删除 API

实现搜索和分页

实现班级、部门管理 API

前端实现表单动态渲染（根据类型）

实现详情页

第三阶段：导入导出与优化（1周）
